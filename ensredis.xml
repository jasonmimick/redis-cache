<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for UNIX (SUSE Linux Enterprise Server for x86-64) 2013.1 (Build 446U)" ts="2013-08-22 13:13:49">
<Project name="ensredis" LastModified="2013-08-22 12:43:20.350286">
  <Items>
    <ProjectItem name="redis.CommandProcessor" type="CLS"></ProjectItem>
    <ProjectItem name="redis.InboundAdapter" type="CLS"></ProjectItem>
    <ProjectItem name="redis.Request" type="CLS"></ProjectItem>
    <ProjectItem name="redis.Response" type="CLS"></ProjectItem>
    <ProjectItem name="redis.Service" type="CLS"></ProjectItem>
    <ProjectItem name="redis.SystemUtilities" type="CLS"></ProjectItem>
    <ProjectItem name="redis.Monitor" type="CLS"></ProjectItem>
    <ProjectItem name="redis.Production" type="CLS"></ProjectItem>
    <ProjectItem name="redis.Tests" type="CLS"></ProjectItem>
    <ProjectItem name="redis.redis.INC" type="MAC"></ProjectItem>
  </Items>
</Project>


<Class name="redis.CommandProcessor">
<Description>
Private methods for each command this redis server implements.
Only entry is through Process() which catches exceptions and returns
%Status'</Description>
<IncludeCode>redis.redis</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>63056,47558.707742</TimeChanged>
<TimeCreated>63054,62803.457889</TimeCreated>

<Property name="CheckedNamespaces">
<Description>
Cache of namespaces we're already checked</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Method name="document">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	#dim method as %Dictionary.MethodDefinition
	set cdef=##class(%Dictionary.ClassDefinition).%OpenId(..%ClassName(1))
	for i=1:1:cdef.Methods.Count() {
		set method = cdef.Methods.GetAt(i)
		set name=method.Name
		if ( name?.U ) {	// all uppercase name => redis command
			set commands(name)="",x=$increment(commandCount)
		}
		if ( name?.U1"and".U ) {
			set commands(name)="",x=$increment(commandCount)
		}
	}
	set name=$order(commands(""))
	while ( name'="" ) { write name,! set name=$order(commands(name)) }
	write "# command supported:",commandCount,!
]]></Implementation>
</Method>

<Method name="%OnNew">
<FormalSpec>type</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $this.CheckedNamespaces($namespace)=""
	return $$$OK
]]></Implementation>
</Method>

<Method name="Process">
<FormalSpec><![CDATA[&request:redis.Request,*response:redis.Response]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim exception as %Exception.AbstractException
	try {
		set $$$clients(request.Client,"addr")=request.Client
		if ( $data( $$$clients(request.Client,"db") ) ) {
			set ns=$$$clients(request.Client,"db")
			if ( '$data(..CheckedNamespaces(ns) ) ) {
				set sc=##class(redis.SystemUtilities).EnsureNamespace( $$$clients("db") )
				if $$$ISERR(sc) $$$ThrowStatus(sc) 
				set $this.CheckedNamespaces(ns)=""
			}
		} else { 			
			set $$$clients(request.Client,"db")=$namespace
		}
		set command = request.Command
		$$$TRACE("command="_command)
		set response=$method($this,command,request)
		return $$$OK
	} catch (exception) {
		$$$TRACE(exception.DisplayString())
		set response=$$$rERROR(exception.DisplayString())
		// We eat and return exceptions from here down
		// as they are "application" issues which we need
		// to send back to the client
		return $$$OK //exception.AsStatus()
	}
]]></Implementation>
</Method>

<Method name="MONITOR">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	// special debugging request to track requests
	set sc=##class(redis.Monitor).Start(.request)
	$$$TRACE("redis.Monitor.Start returned sc="_$system.Status.GetErrorText(sc))
	return $$$rOK
]]></Implementation>
</Method>

<Method name="SUBSCRIBE">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	if ( $data( $$$clients(request.Client,"channels") ) ) {
		set myChannels = $$$clients(request.Client,"channels")
	} else {
		set myChannels = ""
	}
	$$$TRACE("SUBSCRIBE channels="_$listtostring(request.Arguments)_" current ="_$listtostring(myChannels))
	set numChannels=$listlength(request.Arguments)
	for i=1:1:numChannels { 	// for each channel
		set channel=$list(request.Arguments,i)
		// does this client already subscribe?
		if ( '$listfind(myChannels,channel) ) {
			set $list(myChannels,$ll(myChannels)+1)=channel
		}
		set x=$increment($$$channels(channel))
		set $$$channels(channel,request.Client)=x	
		set $$$clients(request.Client,"channels")=myChannels
		set result=$listbuild("subscribe",channel,$listlength(myChannels))
		set response=$$$rBULK(result)
		set sc=response.writeToStream(request.Stream)	
	}
	set response=##class(redis.Monitor).Subscribe(request,channel)
	return response
]]></Implementation>
</Method>

<Method name="UNSUBSCRIBE">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	if ( '$data( $$$clients(request.Client,"channels") ) ) {
		// ain't got no subscriptions!
		return $$$rERROR("No subscriptions found!")
	}
	if ( $listlength(request.Arguments) = 0 ) { // unsubscribe from all
		set channels = $$$clients(request.Client,"channels")
	} else {
		set channels = request.Arguments
	}
	$$$TRACE("UNSUBSCRIBE from "_$listtostring(channels))
	set numChannels=$listlength(channels),response=$$$rOK
	for i=1:1:numChannels { 	// for each channel
		set channel=$list(channels,i)
		// does this client already subscribe?
		set cp=$listfind( $$$clients(request.Clients,"channels"),channel )
		if ( cp=0 ) {
			// not subscribed, continue
			continue
		}
		// remove the channel
		set $list($$$clients(request.Client,"channels"),cp,cp+1)=""
		kill $$$channels(channel,request.Client)	
		set x=$increment($$$channels(channel),-1)
		set numChannels=$listlength($$$clients(request.Client,"channels"))
		set result=$listbuild("unsubscribe",channel,numChannels)
		set response=$$$rBULK(result)
		// save last response to return
		do ##class(redis.Monitor).Unsubscribe(request,channel)
		set:(i<numChannels) sc=response.writeToStream(request.Stream)	
	}
	return response
]]></Implementation>
</Method>

<Method name="PUBLISH">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	if ( $listlength(request.Arguments)'= 2 ) {
		return $$$rERROR("PUBLISH invalid args "_$listtostring(request.Arguments))
	}
	set channel=$list(request.Arguments,1)
	set message=$list(request.Arguments,2)
	$$$TRACE("PUBLISH channel="_channel_" message="_message)
	set i=##class(redis.Monitor).Publish(request,channel,message)
	return $$$rINT(i)
]]></Implementation>
</Method>

<Method name="PING">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    $$$TRACE("PING client="_request.Client)
    return $$$rOKMSG("PONG")
]]></Implementation>
</Method>

<Method name="CLIENT">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	set command = $zconvert($list(request.Arguments,1),"U")
	$$$TRACE("CLIENT command="_command)
	if ( "KILL,LIST,SETNAME,GETNAME"'[command ) {
		return $$$rERROR("UNKNOWN CLIENT COMMAND '"_command_"'")
	}
	set subCommand="CLIENTand"_command
	return $method(subCommand,request)
]]></Implementation>
</Method>

<Method name="CLIENTandLIST">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	//cCLIENTcLIST() [ request.Arguments, result, client ] public {
	set fields=$lb("addr","age","name","db")
	set c=$order($$$clients("")),tr="",cc=0
	while ( c'="" ) {
		set l=""
		for i=1:1:$ll(fields) {
			set f = $list(fields,i)
			set l = l_f_":"_$get($$$clients(c,f),"???")
			set:i<$ll(fields) l=l_" "
		}

	// set tr=tr_"$"_$length(l)_$$$CRLF

	// set tr=tr_l_$$$CRLF,cc=cc+1
	set tr=tr_l_$C(10),cc=cc+1
		set c=$order($$$clients(c))
		//set:(c'="") tr=tr_$C(10)
	}
	//set result="*1"_$$$CRLF_"$"_$l(tr)_$$$CRLF_tr_$$$CRLF
	return $$$rBULK(tr)
]]></Implementation>
</Method>

<Method name="CLIENTandKILL">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	//cCLIENTcKILL() [ request.Arguments, result, client ] public {
	set target=$list(request.Arguments,2)
	if ( '$data($$$clients(target) ) ) {
		return $$$rERROR("CLIENT NOT FOUND")
	}
	if ( $data($$$clients(target,"busy"))) {
		return $$$rERROR("CLIENT BUSY")
	}

	// TODO - use LOCKs on ^redis.clients here
	$$$TRACE("CLIENT KILL *** Locks not implemented ***")
	kill $$$clients(target)
	return $$$rOK
]]></Implementation>
</Method>

<Method name="CLIENTandSETNAME">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	//cCLIENTcSETNAME() [ request.Arguments, result, client ] public {
	set $$$clients(request.Client,ient,"name")=$list(request.Arguments,2)
	return $$$rOK
]]></Implementation>
</Method>

<Method name="CLIENTandGETNAME">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	//cCLIENTcGETNAME() [ request.Arguments, result, client ] public {
	$$$TRACE("cCLIENTcGETNAME client="_client)
	if ( '$data($$$clients(request.Client,"name")) ) {
		return $$$rDNE
	}
	set n = $$$clients(request.Client,"name")
	set result = $$$rBULK(n)
	return result
]]></Implementation>
</Method>

<Method name="SELECT">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	//cSELECT() [ request.Arguments, result, client ] public {	// select a namespace
	set ns=$list(request.Arguments,1)
	if ( '##class(%SYS.Namespace).Exists(ns) ) {
		set result = $$$rERROR("Namespace does not exist")
		return
	}
	set $$$clients(request.Client,"db")=ns
	set $$$control("db",ns)=""	// mark this namespace a being used
	$$$TRACE("SELECT client="_client_" ns="_ns)
	return $$$rOK
]]></Implementation>
</Method>

<Method name="SET">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    if ( $listlength(request.Arguments)'=2 ) {
		return $$$rERROR("SET invalid request.Arguments")
    }
	set key=$list(request.Arguments,1),value=$list(request.Arguments,2)
    set $$$keys(key)=value
    $$$TRACE("SET key="_key_" value="_value)
    return $$$rOK
]]></Implementation>
</Method>

<Method name="MSET">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	if ( ($listlength(request.Arguments)#2)'=0 ) {
		return $$$rERROR("SET invalid request.Arguments")
    }
    for i=1:2:$listlength(request.Arguments) {
		set key=$list(request.Arguments,i)
		set value=$list(request.Arguments,i+1)
		set $$$keys(key)=value
	}
	return $$$rOK
]]></Implementation>
</Method>

<Method name="HSET">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    if ( $listlength(request.Arguments)'=3 ) {
		return $$$rERROR("SET invliad request.Arguments")
    }
	$$$TRACE("HSET")
    set hash=$listget(request.Arguments,1)
    set key=$listget(request.Arguments,2)
    set value=$listget(request.Arguments,3)
    $$$TRACE("HSET hash="_hash_" key="_key_" value="_value)
    set $$$hashes(hash,key)=value
    return $$$rOK
]]></Implementation>
</Method>

<Method name="HSETNX">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    if ( $listlength(request.Arguments)'=3 ) {
		return $$$rERROR("SET invliad request.Arguments")
    }
    $$$TRACE("HSETNX")
    set hash=$listget(request.Arguments,1)
    set key=$listget(request.Arguments,2)
    set value=$listget(request.Arguments,3)
    $$$TRACE("HSET hash="_hash_" key="_key_" value="_value)
    if ( '$data( $$$hashes(hash,key) ) ) {  // only set if does NOT exist!
    	set $$$hashes(hash,key)=value
	return $$$rINT(1)
    }
    // field exists, do nothing & return 0
    return $$$rINT(0)
]]></Implementation>
</Method>

<Method name="HINCRBY">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    if ( $listlength(request.Arguments)'=3 ) {
	return $$$rERROR("HINCRBY invliad request.Arguments")
    }
    $$$TRACE("HINCRBY")
    set hash=$listget(request.Arguments,1)
    set key=$listget(request.Arguments,2)
    set value=+$listget(request.Arguments,3)  // convert to int implicit!
    $$$TRACE("HSET hash="_hash_" key="_key_" value="_value)
    // exist or not, the key is convert to number
    set $$$hashes(hash,key)=+$get($$$hashes(hash,key))+value
    return $$$rINT( $$$hashes(hash,key) )
]]></Implementation>
</Method>

<Method name="HINCRBYFLOAT">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    if ( $listlength(request.Arguments)'=3 ) {
	return $$$rERROR("HINCRBYFLOAT invliad request.Arguments")
    }
    $$$TRACE("HINCRBYFLOAT")
    set hash=$listget(request.Arguments,1)
    set key=$listget(request.Arguments,2)
    set value=+$listget(request.Arguments,3)  // convert to int implicit!
    $$$TRACE("HSET hash="_hash_" key="_key_" value="_value)
    // exist or not, the key is convert to number
    set $$$hashes(hash,key)=+$get($$$hashes(hash,key))+value
    return $$$rBULK( $$$hashes(hash,key) )
]]></Implementation>
</Method>

<Method name="HMSET">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    if ( $listlength(request.Arguments)<3 ) {
	return $$$rERROR("HMSET invalid request.Arguments")
    }
    // Error here if not even number of key/value pairs
    // the number of args should be at least 3 and ODD
    if ( ($listlength(request.Arguments)#2)'=1 ) {
	return $$$rERROR("HMSET invalid request.Arguments")
    }
 
    $$$TRACE("HMSET")
    set hash=$listget(request.Arguments,1)
    for i=2:2:$listlength(request.Arguments) {
        set key=$listget(request.Arguments,i)
        set value=$listget(request.Arguments,i+1)
        $$$TRACE("HMSET hash="_hash_" key="_key_" value="_value)
        set $$$hashes(hash,key)=value
    }
    return $$$rOK
]]></Implementation>
</Method>

<Method name="APPEND">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    set key=$list(request.Arguments,1)
    set val=$list(request.Arguments,2)
    $$$TRACE("APPEND key="_key_" val="_val_" old="_$get($$$keys(key)))
    set $$$keys(key)=$get($$$keys(key))_val
  	return $$$rOK
]]></Implementation>
</Method>

<Method name="EXISTS">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    set key=$list(request.Arguments,1)
    $$$TRACE("EXISTS key="_key)
    if ( $data( $$$keys(key) ) ) {
	return $$$rINT(1)
    } else {
	return $$$rINT(0)
    }
]]></Implementation>
</Method>

<Method name="HEXISTS">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    set key=$list(request.Arguments,1),field=$list(request.Arguments,2)
    $$$TRACE("HEXISTS key="_key_" field="_field)
    if ( $data( $$$hashes(key,field) ) ) {
	return $$$rINT(1)
    } else {
	return $$$rINT(0)
    }
]]></Implementation>
</Method>

<Method name="DEL">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	
    set key=$list(request.Arguments,1)
    $$$TRACE("DEL key="_key)
    if ( '$data($$$keys(key)) ) {
		$$$TRACE("DEL key does not exist")
		return $$$rDNE
    }
    // TODO: Lock before kill, check $Test, etc
    kill $$$keys(key)
    set result=$$$rOK
    $$$TRACE("DEL result="_result.toString())
    return result
]]></Implementation>
</Method>

<Method name="GET">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	
    set key=$list(request.Arguments,1)
    $$$TRACE("GET key="_key)
    if ( '$data($$$keys(key)) ) {
		$$$TRACE("GET key does not exist")
		return $$$rDNE
    }
	set value=$$$keys(key)
    $$$TRACE("GET key="_key_" value="_value)
	if ( value?.N ) {
		set result = $$$rINT(value)   // integer
	}else {
	    set result=$$$rBULK(value)
	}
	$$$TRACE("GET result="_result.toString())
	return result
]]></Implementation>
</Method>

<Method name="GETRANGE">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    set key=$list(request.Arguments,1)
    if ( '$data($$$keys(key)) ) {
		$$$TRACE("GETRANGE key does not exist")
		return $$$rDNE
    }
	set value=$$$keys(key)
    $$$TRACE("GETRANGE key="_key_" value="_value)
    set start=$list(request.Arguments,2),end=$list(request.Arguments,3)
    set value=$extract(value,start,end)
    $$$TRACE("GETRANGE start="_start_" end="_end_" value="_value)
    if ( value?.N ) {
		set result = $$$rINT(value)   // integer
    }else {
	    set result=$$$rBULK(value)
	}
	return result
]]></Implementation>
</Method>

<Method name="HDEL">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    set hash=$list(request.Arguments,1)
    if ( '$data($$$hashes(hash)) ) {
		$$$TRACE("HDEL hash="_hash_" does not exist")
		return $$$rINT(0)
    }
    for i=2:1:$listlength(request.Arguments) {
	set field=$listget(request.Arguments,i)
	if ( $data($$$hashes(hash,field) ) ) {
		// TODO: Lock?
		$$$TRACE("HDEL removing "_hash_"."_field)
		kill $$$hashes(hash,field)
		set x=$increment(removedFieldCount)
	}
    }
    set result = $$$rINT(removedFieldCount)   // integer
    return result
]]></Implementation>
</Method>

<Method name="HGET">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    set hash=$list(request.Arguments,1),field=$list(request.Arguments,2)
    if ( '$data($$$hashes(hash,field)) ) {
		$$$TRACE("HGET hash="_hash_" field="_field_" does not exist")
		return $$$rDNE
    }
	set value=$$$hashes(hash,field)
    $$$TRACE("HGET hash="_hash_" field="_field_" value="_value)
	if ( value?.N ) {
		set result = $$$rINT(value)   // integer
	}else {
	    set result=$$$rBULK(value)
	}
	return result
]]></Implementation>
</Method>

<Method name="HLEN">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    set hash=$list(request.Arguments,1)
    if ( '$data($$$hashes(hash)) ) {
	$$$TRACE("HGET hash="_hash_" does not exist")
	return $$$rERROR("hash '"_hash_"' does not exist")
    }
    set key=$order($$$hashes(hash,""))
    while ( key'="" ) {
	set x=$increment(keyCount)
	set key=$order($$$hashes(hash,key))
    }
    set result=$$$rINT(keyCount)
    return result
]]></Implementation>
</Method>

<Method name="HKEYS">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    set hash=$list(request.Arguments,1)
    if ( '$data($$$hashes(hash)) ) {
	$$$TRACE("HGET hash="_hash_" does not exist")
	return $$$rERROR("hash '"_hash_"' does not exist")
    }
    set key=$order($$$hashes(hash,""))
    while ( key'="" ) {
	set $list(keys,$increment(keyCount))=key
	set key=$order($$$hashes(hash,key))
    }
    set result=$$$rBULK(keys)
    return result
]]></Implementation>
</Method>

<Method name="HMGET">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    set hash=$list(request.Arguments,1)
    if ( '$data($$$hashes(hash)) ) {
		$$$TRACE("HGET hash="_hash_" does not exist")
		return $$$rDNE
    }
    for i=2:1:$listlength(request.Arguments) {
	set field=$list(request.Arguments,i)
	if ( $data( $$$hashes(hash,field) ) ) {
		set value=$$$hashes(hash,field)
        	$$$TRACE("HMGET hash="_hash_" field="_field_" value="_value)
		set $list(values,i-1)=value
	}  // NOTE! non-exists fields map to (nil) list elements
    }
    set result=$$$rBULK(values)
    return result
]]></Implementation>
</Method>

<Method name="HGETALL">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	set hash=$list(request.Arguments,1)
	set field=$order($$$hashes(hash,""))
	$$$TRACE("HGETALL hash="_hash_" field="_field)
	set counter=0
	while ( field'="" ) {
		// key
		set $list(results,$i(counter)) = field
		// value
		set value = $$$hashes(hash,field)
		set $list(results,$i(counter)) = value 
		set field=$order($$$hashes(hash,field))
	}
	$$$TRACE("HGETALL results="_$listtostring(results))
	set result = $$$rBULK(results)
	$$$TRACE("HGETALL result="_result.toString())
	return result
]]></Implementation>
</Method>

<Method name="GETSET">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
    set getResult=..GET(request)
    $$$TRACE("GETSET getResult="_getResult.toString())
    set setResult=..SET(request)
    $$$TRACE("GETSET setResult="_setResult.toString())
    return getResult
]]></Implementation>
</Method>

<Method name="INCR">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	set key=$list(request.Arguments,1)
	set i=$i($$$keys(key))
	$$$TRACE("INCR key="_key_" value="_i)
	return $$$rINT(i)
]]></Implementation>
</Method>

<Method name="INCRBY">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	set key=$list(request.Arguments,1)
	set by=$list(request.Arguments,2)
	set i=$i($$$keys(key),by)
	$$$TRACE("INCRBY key="_key_" value="_i)
	return $$$rINT(i)
]]></Implementation>
</Method>

<Method name="DECR">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	set key=$list(request.Arguments,1)
	set i=$i($$$keys(key),-1)
	$$$TRACE("DECR key="_key_" value="_i)
	return $$$rINT(i)
]]></Implementation>
</Method>

<Method name="DECRBY">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	set key=$list(request.Arguments,1)
	set by=$list(request.Arguments,2)
	set i=$i($$$keys(key),-by)
	$$$TRACE("DECRBY key="_key_" value="_i)
	return $$$rINT(i)
]]></Implementation>
</Method>

<Method name="LLEN">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	set key=$list(request.Arguments,1)
	if ( '$listdata($$$lists(key)) ) {
		//nil
		return $$$rDNE
	}
	set i=$listlength($$$lists(key))
	return $$$rINT(i)
]]></Implementation>
</Method>

<Method name="LPUSH">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	//cLPUSH() [ request.Arguments, result, client ] public {
	set key=$list(request.Arguments,1)
	set value=$list(request.Arguments,2)
	$$$TRACE("LPUSH key="_key_" value="_value)
	set $$$lists(key)=$lb(value)_$get($$$lists(key))
	return $$$rINT($listlength($$$lists(key)))
]]></Implementation>
</Method>

<Method name="LPOP">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	set key=$list(request.Arguments,1)
	if ( '$listdata($$$lists(key) ) ) {
		//nill
		return $$$rDNE
	}
	set value=$list($$$lists(key),1)
	set $list($$$lists(key),1,1)=""	// remove first element
	set result=$$$rBULK(value)
]]></Implementation>
</Method>

<Method name="LRANGE">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	set key=$list(request.Arguments,1)
	if ( '$data($$$lists(key) ) ) {
		return $$$rDNE
	}
	$$$TRACE("LRANGE key="_key_" request="_request.toString())
	if ( $listlength(request.Arguments) '= 3 ) {
		return $$$rERROR("LRANGE needs start,stop parameters")
	}
	set start=+$list(request.Arguments,2),stop=+$list(request.Arguments,3)
	$$$TRACE("LRANGE start="_start_" stop="_stop)
	//set emptyListResult="*0"_$$$CRLF
	if ( start > $listlength($$$lists(key)) ) {
		//set result=emptyListResult
		return $$$rBULK($lb())
	}
	if ( stop > $listlength( $$$lists(key) ) ) {
		set stop=$listlength( $$$lists(key) )
	}
	set range=$list($$$lists(key),start,stop),result=""
	$$$TRACE("LRANGE range="_$listtostring(range))
	return $$$rBULK(range)
]]></Implementation>
</Method>

<Method name="RPUSH">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	//cRPUSH() [ request.Arguments, result, client ] public {
	set key=$list(request.Arguments,1)
	set value=$list(request.Arguments,2)
	$$$TRACE("RPUSH key="_key_" value="_value)
#if $ZV["2013.2"
	set $list($$$lists(key),*+1)=value
#else
	set $$$lists(key)=$$$lists(key)_$lb(value)
#endif
	set result=$$$rINT($listlength($$$lists(key)))
]]></Implementation>
</Method>

<Method name="RPOP">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	//cRPOP() [ request.Arguments, result, client ] public {
	set key=$list(request.Arguments,1)
	if ( '$listdata($$$lists(key) ) ) {
		//nill
		return $$$rDNE
	}
#if $ZV["2013.2"
	set value=$list($$$lists(key),*)
#else
	set value=$list($$$lists(key),$listlength($$$lists(key)))
#endif
	set length=$listlength($$$lists(key))
	set $list($$$lists(key),length,length)=""	// remove last element
	set result=$$$rBULK(value)
]]></Implementation>
</Method>

<Method name="SADD">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	//cSADD() [ request.Arguments, result, client ] public {
	set key=$list(request.Arguments,1)
	set numToAdd=$listlength(request.Arguments)-1
	$$$TRACE("SADD key="_key_" numToAdd="_numToAdd_" request.Arguments="_$listtostring($list(request.Arguments,2,$ll(request.Arguments))))
	for i=1:1:numToAdd {
		set e=$list(request.Arguments,i+1)
		if ('$data($$$sets(key,e))) {
		 set x=$i($$$sets(key))
		 set $$$sets(key,e)=""
		}
	}
	set result=$$$rINT($$$sets(key))
]]></Implementation>
</Method>

<Method name="SPOP">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	//cSPOP() [ request.Arguments, result, client ] public {
	// remove and return a random element from a set
	set key=$list(request.Arguments,1)
	if ( '$data($$$sets(key) ) ) {
		//nill
		return $$$rDNE
	}
	set r=$random($$$sets(key))+1,value=$order($$$sets(key,""))
	for i=1:1:(r-1) set value=$order($$$sets(key,value))
	$$$TRACE("r="_r_" value="_value)
	set x=$increment($$$sets(key),-1)
	if ( x=0 ) { 
		kill $$$sets(key) 
	} else {
		kill $$$sets(key,value)
	}
	return $$$rBULK(value)
]]></Implementation>
</Method>

<Method name="SMEMBERS">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	//cSMEMBERS() [ request.Arguments, result, client ] public {
	set key=$list(request.Arguments,1)
	if ( '$data($$$sets(key) ) ) {
		//nill
		return $$$rDNE
	}
	set value=$order($$$sets(key,"")),values=$lb()
	while ( value'="" ) {
		set values=values_$lb(value)
		set value=$order($$$sets(key,value))
	}
	set result = $$$rBULK(values)
]]></Implementation>
</Method>

<Method name="INFO">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	//cINFO() [ request.Arguments, result, client ] public {
	set xr=$lb("# Server")
	set xr=xr_$lb("cache_redis_server_version:"_$$$VERSION)
	set xr=xr_$lb("os:"_$ZV)
	set xr=xr_$lb("timestamp:"_$system.SYS.TimeStamp())
	set xr=xr_$lb("process_id:"_$system.SYS.ProcessID())
	set xr=xr_$lb("user_memory_human:"_$piece($view(-1,$job),"^",17))	
	set xr=xr_$lb(" ")
	set xr=xr_$lb("# redis.conf")
	set key=$order($$$conf(""))
	while ( key'="" ) {
		set xr=xr_$lb(key_":"_$$$conf(key))
		set key=$order($$$conf(key))
	}
	set result=$$$rBULK(xr)
	$$$TRACE("INFO result="_result.toString())
	return result
]]></Implementation>
</Method>

<Method name="KEYS">
<FormalSpec>request:redis.Request</FormalSpec>
<Private>1</Private>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("KEYS command - wildcard, pattern matching not implemented")
	set (oq,q)=$listget(request.Arguments,1,"*"),mode=1
	$$$TRACE("KEYS q="_q_" mode="_mode)
	if ( q["?" ) {
		set q=$tr(q,"?","*"),mode=2
	}
	if ( q["[" ) {
		set q=$p(q,"[",1)_"*"_$p(q,"]",2),mode=3
	}
	kill r
	set key=$order($$$keys(""))
	while ( key'="" ) {	
		set r($i(r))=key
		$$$TRACE("r("_r_")="_r(r))
		set key=$order($$$keys(key))
	}
	merge s=r
	$$$TRACE("s="_s)
	if ( mode = 2 ) {
		for i=1:1:r {
			if ( $l(r(i))'=$l(oq) ) {
				set s=s-1
				kill s(i)
			}
		}
	}
	
	if ( mode = 3 ) { 		// to-do
		return $$$rERROR("Not implemented")
	}
	
	
	set results=$lb()
	set i=$order(s(""))
	while ( i'="" ) {
		set v=s(i)
		set results=results_$lb(v)
		set i=$order(s(i))
	}
	set result=$$$rBULK(results)
	$$$TRACE(result)
	return result
]]></Implementation>
</Method>
</Class>


<Class name="redis.InboundAdapter">
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.TCP.InboundAdapter,EnsLib.TCP.TextLineCommon</Super>
<TimeChanged>63055,68333.142151</TimeChanged>
<TimeCreated>63053,73322.20215</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="SERVICEINPUTCLASS">
<Default>redis.Request</Default>
</Parameter>

<Parameter name="SERVICEOUTPUTCLASS">
<Default>redis.Response</Default>
</Parameter>

<UDLText name="T">
<Content><![CDATA[/* override (empty) superclass initial Terminators value */
]]></Content>
</UDLText>

<Property name="Terminators">
<Type>%String</Type>
<InitialExpression>$C(13,10)</InitialExpression>
</Property>

<Method name="OnConnected">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set redisRequest=$$$NULLOREF
	Set tQuitErr=1  Do {
		//Set tSC=..ReadLine(.tInStr,..CallInterval,1)
		set ..Socket.LineTerminator=$C(13,10)
		Set tSC = ##class(redis.Request).readFromStream(..Socket,.redisRequest)
		set redisRequest.Client = $piece(..IOAddr,"-",2)
		If $$$ISERR(tSC) {
			If ..IsReadError(tSC) {
				Set tSC=$$$ERROR($$$EnsErrInConnectionLost,"TCP Read Line",..IOAddr,$$$StatusDisplayString(tSC))
				Set tQuitErr=0  Do ..Disconnect()
				If ""=redisRequest Set tTxt=$$$StatusText(tSC), tSC=$$$OK  If ..StayConnected<0 { $$$LOGWARNING(tTxt) } ElseIf ..%logConnections { $$$LOGINFO(tTxt) } Else { $$$sysTRACE(tTxt) } ; change error to info if lost connection with no data and trying to stay connected
			} ElseIf $$$StatusEquals(tSC,$$$EnsErrTCPTerminatedReadTimeoutExpired) {
				If ""=redisRequest { Set tSC=$$$OK } ; no error if timed out with no data
				Else { Set tQuitErr=0 }
			}
			Quit
		}
		$$$ANEWINIOLOGENTRY($$$OK,"redis.Inbound req :"_..IOAddr,redisRequest.toString())
		$$$TRACE("request="_redisRequest.toString())
		// If someone is monitoring, signal them
		// TODO: Refactor into CommandProcessor
		if ( $get(^redis.monitor,0)=1 ) {
			$$$TRACE("^redis.montior is 1")
			set rlist=$system.Event.List()
			for i=1:1:$listlength(rlist) {
				if ($list(rlist,i)["redis.monitor") {
					set msg=redisRequest.toString()
					$$$TRACE("sending to '"_$list(rlist,i)_"' msg="_msg)
					do $system.Event.Signal($list(rlist,i),msg)
				}
			}
		}
		// Process the request
		Set tSC=..BusinessHost.ProcessInput(.redisRequest, .redisResponse)  Quit:$$$ISERR(tSC)
		
		If $D(redisResponse) {
			If $IsObject(redisResponse) {
				$$$ASSERT(redisResponse.%Extends("redis.Response"))
				if ( '$isobject(redisResponse.Request) ) {
					set redisResponse.Request=residRequest
				}
				//Set tStringOut=tStringOut.StringValue
			}
		} Else { Set redisResponse=##class(redis.Response).Error("UNKNOWN") }
		If $$$ISERR(tSC) {
			$$$ACLOSEIOLOGENTRY(tSC,"after TCP TextLine ProcessInput error on :"_..IOAddr,redisRequest.toString())
			Quit
		}
		//If ""'=tStringOut {
		If $isobject(redisResponse) {
			;#$$$sysTRACE("Returning Output String '"_tStringOut_"'")
			//Set tSC=..WriteLine(tStringOut,1)
			Set tSC = redisResponse.writeToStream(..Socket)
			If $$$ISERR(tSC) {
				If ..IsWriteError(tSC) {
					Set tSC=$$$ERROR($$$EnsErrInConnectionLost,"TCP Write Line",..IOAddr,$$$StatusDisplayString(tSC))
					Set tQuitErr=0  Do ..Disconnect()
				}
				$$$ACLOSEIOLOGENTRY(tSC,"after TCP WriteLine error on :"_..IOAddr,"redisReponse.toString()")
				Quit
			}
			$$$ACLOSEIOLOGENTRY(tSC,"after TCP WriteLine on :"_..IOAddr,"redisReponse.toString()")
		} Else {
			$$$ACLOSEIOLOGENTRY(tSC,"after TCP ProcessInput on :"_..IOAddr,"")
		}
	} While 0
	#; Returning error status would cause this listener job to terminate
	If $$$ISERR(tSC) {
		#; Never quit the listener, but drop the connection on unrecognized error
		If tQuitErr&&..Connected&&..StayConnected { $$$LOGERROR("Disconnecting due to "_$$$StatusDisplayString(tSC)) Set tSC=$$$OK  Do ..Disconnect() }
		If $$$ISERR(tSC) $$$LOGSTATUS(tSC)
	}
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="redis.Request">
<IncludeCode>Ensemble</IncludeCode>
<Super>%Persistent</Super>
<TimeChanged>63056,45690</TimeChanged>
<TimeCreated>63053,62016.665934</TimeCreated>

<Property name="Client">
<Description>
IP/port of client making the request</Description>
<Type>%String</Type>
</Property>

<Property name="IsInline">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Command">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Stream">
<Type>%IO.DeviceStream</Type>
</Property>

<Method name="CommandGet">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	return $zconvert(i%Command,"U")
]]></Implementation>
</Method>

<Property name="Arguments">
<Type>%List</Type>
<InitialExpression>$listbuild()</InitialExpression>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="toString">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set cc=$this.Command,aa=$this.Arguments
	set c=$get(cc,"command?")
	if ( $listdata(aa ) ) {
		set l=$listtostring(aa)
	} else {
		set l="empty"
	}
	return "Command="_c_" IsInline="_..IsInline_" Arguments="_l_" Client="_..Client
]]></Implementation>
</Method>

<Method name="getChannelEvent">
<FormalSpec>channel:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	return "^redis.channels("""_channel_""","""_$this.Client_""")"
]]></Implementation>
</Method>

<Method name="processInlineBuffer">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[stream,firstLine,&request:redis.Request]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("processInlineBuffer firstLine="_firstLine)
	set status=$$$OK
	set data=firstLine //stream.ReadLine()
	set args=$listfromstring(data," ")
	set request=##class(redis.Request).%New()
	set request.Command=$list(args,1)
	set request.Arguments=$list(args,2,$listlength(args))
	set request.IsInline=1
	return status
]]></Implementation>
</Method>

<Method name="readFromStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>stream,*request:redis.Request,*timeout:%Numeric=-1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//break
	Set request=##class(redis.Request).%New()
	Set request.Stream = stream
	Set request.Command = ""
	//Set request.Client=$piece(stream.Remote,"|",2)
	set request.Arguments=$lb()
	set numArgsStr="",initialTimeout=timeout
	$$$TRACE("readFromStream initialTimeout="_initialTimeout_" timeout="_timeout)
	do {
		set timeout=initialTimeout
		set numArgsStr = stream.ReadLine(,.timeout,.status)
		if (timeout'=0) $$$TRACE("numArgsStr="_numArgsStr_" timeout="_timeout_" status="_status)
		Quit:(timeout'=0) 
		Quit:$$$ISERR(status) 
	} while ( numArgsStr="")
	Quit:(timeout'=0) $$$OK
	Quit:$$$ISERR(status) status

	if ( $extract(numArgsStr,1)'="*" ) { // Inline request
		return ..processInlineBuffer(stream,numArgsStr,.request)
	}
	set numArgs=$e(numArgsStr,2,*)
	if ( numArgs'?.N ) {
		throw ##class(%Exception.General).%New("Invalid Argument Count",,"numArgsStr='"_numArgsStr_"'")
	}
	$$$TRACE("numArgs="_numArgs)
	set cmdByteCount=""
	// From here on - we do not timeout!
	// since we already got the start of a command
	do {
		set cmdByteCount=stream.ReadLine(,,.status)
		$$$TRACE("cmdByteCount="_cmdByteCount)
	} while ( cmdByteCount="") 
	Quit:$$$ISERR(status) status
	do {
		set request.Command=stream.ReadLine(,,.status)
	} while ( request.Command="")
	$$$TRACE("request.Command="_request.Command_" status="_status)
	Quit:$$$ISERR(status) status
	for i=1:1:(numArgs-1) {
		set byteCount=""
		do {
			set byteCount = stream.ReadLine(,,.status)
		} while ( byteCount="")
		Quit:$$$ISERR(status)
		set arg=""
		do {
			set arg=stream.ReadLine(,,.status)
			quit:$$$ISERR(status)
		} while ( arg="" )
		set $list(request.Arguments,i)=arg
		
	}
	return status
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^redis.RequestD</DataLocation>
<DefaultData>RequestDefaultData</DefaultData>
<IdLocation>^redis.RequestD</IdLocation>
<IndexLocation>^redis.RequestI</IndexLocation>
<StreamLocation>^redis.RequestS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="RequestDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Command</Value>
</Value>
<Value name="3">
<Value>Arguments</Value>
</Value>
<Value name="4">
<Value>IsInline</Value>
</Value>
<Value name="5">
<Value>Client</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="redis.Response">
<IncludeCode>Ensemble</IncludeCode>
<Super>%Persistent</Super>
<TimeChanged>63056,45690</TimeChanged>
<TimeCreated>63053,63287.439318</TimeCreated>

<Parameter name="STATUS">
<Default>+</Default>
</Parameter>

<Parameter name="ERROR">
<Default>-</Default>
</Parameter>

<Parameter name="INTEGER">
<Default>:</Default>
</Parameter>

<Parameter name="BULK">
<Default>$</Default>
</Parameter>

<Parameter name="MULTIBULK">
<Default>*</Default>
</Parameter>

<Property name="Type">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Request">
<Type>redis.Request</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>type</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if ( $data(type) ) {
		set $this.Type = type
	} else {
		set $this.Type = ""
	}
	return $$$OK
]]></Implementation>
</Method>

<Property name="Args">
<Type>%List</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="toString">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set c=$get(..Type,"type?")
	set l=$listtostring($get(..Args,$lb("args?")))
	return "Type"_c_" Args="_l
]]></Implementation>
</Method>

<Method name="OK">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&response:%String="OK",&req:redis.Request]]></FormalSpec>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	set r=##class(redis.Response).%New(..#STATUS)
	set r.Args=$lb(response)
	set r.Request = req
	return r
]]></Implementation>
</Method>

<Method name="Error">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[msg:%String,&req:redis.Request]]></FormalSpec>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	set r=##class(redis.Response).%New(..#ERROR)
	set r.Args=$lb(msg)
	set r.Request=req
	return r
]]></Implementation>
</Method>

<Method name="Int">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[i:%Integer,&req:redis.Request]]></FormalSpec>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	set r=##class(redis.Response).%New(..#INTEGER)
	set r.Args=$lb(i)
	set r.Request = req
	return r
]]></Implementation>
</Method>

<Method name="Bulk">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[args:%List,&req:redis.Request]]></FormalSpec>
<ReturnType>redis.Response</ReturnType>
<Implementation><![CDATA[
	set r=##class(redis.Response).%New()
	if ( $listvalid(args) ) {
		set r.Args=args
	} else {
		if ( args["," ) {
			set r.Args=$listfromstring(args)
		} else {
			set r.Args=$listbuild(args)
		}
	}
	set r.Request=req
	return r
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// Method writeToStream(ByRef stream As %Stream)

]]></Content>
</UDLText>

<Method name="writeToStream">
<FormalSpec>stream</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set status = $$$OK
	// is status?
	if ( $this.Type = $this.#STATUS ) {
		$$$TRACE("writeToStream #STATUS:"_$list($this.Args,1))
		do stream.WriteLine( $this.#STATUS _ $list($this.Args,1),1,.status )
		return status
	}
	// is error?
	if ( $this.Type = $this.#ERROR ) {
		do stream.WriteLine( $this.#ERROR _ $list($this.Args,1),1,.status )
		return status

	}
	// is int?
	if ( $this.Type = $this.#INTEGER ) {
		do stream.WriteLine( $this.#INTEGER _ $list($this.Args,1),1,.status )
		return status
	}
	set argCount = $listlength($this.Args)
	if ( argCount > 1 ) { // MultiBulk
		do stream.WriteLine( $this.#MULTIBULK _ argCount,1,.status )
		return:$$$ISERR(status) status
		for i=1:1:argCount {
			if ( $listdata($this.Args,i) ) {
				set data=$list($this.Args,i)
				$$$TRACE("data="_data_" $length(data)="_$length(data))
				if ( data?.N ) { // integer
				  do stream.WriteLine( $this.#INTEGER _ data,1,.status)
				  quit:$$$ISERR(status)
				} else {	
				  do stream.WriteLine( $this.#BULK _ $length(data),1,.status)
				  quit:$$$ISERR(status)
				  do:$l(data)>0 stream.WriteLine( data,1,.status )
				  quit:$$$ISERR(status)
				}
			} else {
				do stream.WriteLine( $this.#BULK _ "-1",1,.status )
				quit:$$$ISERR(status)
			}
		}
		return:$$$ISERR(status) status
	} else { // Bulk
		if ( $listdata($this.Args,1) ) {	
			set data=$list($this.Args,1)
			do stream.WriteLine( $this.#BULK _ $length(data),1,.status)
			return:$$$ISERR(status) status
			do:$l(data)>0 stream.WriteLine( data,1,.status )
			return:$$$ISERR(status) status
		} else {
			do stream.WriteLine( $this.#BULK _ "0",1,.status )
			return:$$$ISERR(status) status
		}
	}
	return status
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^redis.ResponseD</DataLocation>
<DefaultData>ResponseDefaultData</DefaultData>
<IdLocation>^redis.ResponseD</IdLocation>
<IndexLocation>^redis.ResponseI</IndexLocation>
<StreamLocation>^redis.ResponseS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="ResponseDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Type</Value>
</Value>
<Value name="3">
<Value>Args</Value>
</Value>
<Value name="4">
<Value>Request</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="redis.Service">
<Super>Ens.BusinessService</Super>
<TimeChanged>63055,61963.830024</TimeChanged>
<TimeCreated>63050,42203.917966</TimeCreated>

<Parameter name="ADAPTER">
<Default>redis.InboundAdapter</Default>
</Parameter>

<Property name="CommandProcessor">
<Type>redis.CommandProcessor</Type>
</Property>

<Method name="OnInit">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $this.CommandProcessor=##class(redis.CommandProcessor).%New()
	$$$TRACE("$this.CommandProcessor="_$this.CommandProcessor)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnProcessInput">
<FormalSpec>redisRequest:redis.Request,*redisResponse:redis.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

	Set redisResponse=$$$NULLOREF
	$$$TRACE("OnProcessInput---"_redisRequest.toString())		
	set status=$this.CommandProcessor.Process(redisRequest,.redisResponse)
	
	/*
	set command = redisRequest.Command
	if ( command="PING" ) {
		set redisResponse=##class(redis.Response).OK("PONG",.redisRequest)
		
	} else {
		set redisResponse=##class(redis.Response).Error("unknown command '"_command_"'",.redisRequest)
	}
	*/
	$$$TRACE("OnProcessInput response="_redisResponse.toString())
	Quit status
]]></Implementation>
</Method>
</Class>


<Class name="redis.SystemUtilities">
<IncludeCode>redis.redis</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>63055,67889.886019</TimeChanged>
<TimeCreated>63055,65923.870031</TimeCreated>

<Method name="EnsureNamespace">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("ensureSN ns="_ns)
	return:##class(%SYS.Namespace).Exists(ns) $$$OK
	// On SELECT commands, ensure the requested namespace is available
	if ( ns?.N ) {
		set ns=$$$nsPrefix_ns	// support redis "0","1" dbs
	}
	$$$TRACE("ensureNS ns="_ns_" did not exist!")
	set dbname=ns
	new $namespace
	set $namespace="%SYS"
	set dbo=##class(Config.Databases).%OpenId(dbname)		
	if ( '$isobject(dbo) ) {
		$$$TRACE("dbo not an object, need to create db")
		set sc=..CreateDatabase(dbname)
		$$$TRACE(sc)
		if ($$$ISERR(sc) ) {
			//zn currNS
			return sc
		}
	}
	// db exist's, now create ns
	set p("Globals")=dbname
	set sc=##class(Config.Namespaces).Create(ns,.p)
	// create mappings for control structures
	$$$TRACE(sc)
	return sc
]]></Implementation>
</Method>

<Method name="CreateDatabase">
<ClassMethod>1</ClassMethod>
<FormalSpec>DBName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set sc=$$$OK
	new $namespace
	set $namespace="%SYS"
	$$$debug("createDb dbname="_DBName)
	set dbNameU=$zconvert(DBName,"U")
	if ( ##class(Config.Databases).Exists(dbNameU,.db) ) {
		$$$debug("DB exists")
		return $$$OK
	} 
	set dir=$system.Util.ManagerDirectory()_DBName
	set dirExists=##class(%File).Exists(dir)
	$$$debug("dirExists="_dirExists)
	if ( 'dirExists ) {
		set created=##class(%File).CreateDirectory(dir)  
		$$$debug("created dir = "_created)
		if ( 'created ) {
			return $$$ERROR("Could not create directory '"_dir_"'")
		}
	}
	set p("Directory")=dir
	set p("Name")=DBName
	set sc=##class(Config.Databases).Create(DBName,.p)
	set dbo=##class(Config.Databases).Open(DBName)
	set sc=dbo.%Save()
	return:$$$ISERR(sc) sc
	
	set db=##class(SYS.Database).%New()
	set db.Directory=dir
	set sc=db.%Save()
	return sc
]]></Implementation>
</Method>

<Method name="DeleteDatabase">
<ClassMethod>1</ClassMethod>
<FormalSpec>DBName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	new $namespace
	set $namespace="%SYS"
	$$$TRACE("deleteDb dbname="_dbname)
	set result=##class(Config.Databases).Delete(dbname)
	$$$TRACE("deletDb result="_result)
	return result
]]></Implementation>
</Method>
</Class>

<Class name="redis.Monitor">
<IncludeCode>redis.redis</IncludeCode>
<Super>%RegisteredObject</Super>

<Method name="Subscribe">
<ClassMethod>1</ClassMethod>
<FormalSpec>request:redis.Request,channel:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// wait on the channel for messages
	// when you get one, send it to the request.Stream
	set in=request.getChannelEvent(channel)	//"^redis.channels("""_channel_""")"
	if ( '$system.Event.Defined(in) ) {
		set ret=$system.Event.Create(in)
	}
	// any stored message on this channel
	set numStoredMessages=$get( $$$channelmessages(channel), 0 )
	for i=1:1:numStoredMessages {
		set m=$$$channelmessages(channel,i)
		set r=$$$rBULK($listbuild("message",channel,m))
		set sc=r.writeToStream(request.Stream)
	}
	set subscribed=1
	while ( subscribed ) {
		set timeout=$$$PUBSUBPOLLINTERAL
		set msgl=$system.Event.WaitMsg(in,timeout)
		$$$TRACE("Sub got msg="_$listtostring(msgl))
		if ( $list(msgl,1) = 1 ) {
			set msg=$list(msgl,2)
			if ( msg="UNSUBSCRIBE" ) {
				set subscribed=0
				quit
			}
			set r=$$$rBULK($listbuild("message",channel,msg))
			set sc=r.writeToStream(request.Stream)
		}
		if ( $list(msgl,1) = -1 ) {
			set subscribed=0
			$$$TRACE("Subscribe WaitMsg return -1, deleted in="_in)
			quit
		}
		// otherwise, WaitMg timedout - 
		// check wire for any new requests.
		// - the client won't send command on same socket
		// - they should use CLIENT SETNAME
		// - make another connection, set to same name
		// - and issue unsubscribe from there!
		/*
		try {
		  $$$TRACE("Subscribe - about to read - timeout="_timeout)
		  Set sc = ##class(redis.Request).readFromStream(request.Stream,.newRequest,.timeout)
		  $$$TRACE("Subscribe - read - timeout="_timeout)
		  if ( timeout=0 ) { // did not timeout
			if ( $isobject(newRequest) ) {
				$$$TRACE("new request="_newRequest.toString())
			} else {
				$$$TRACE("Got new request, but not object:"_newRequest)
			}
		  }
		} catch (exp) {
			$$$TRACE("Subscribe read try/catch exp="_exp.DisplayString())
			set subscribed=0
		}
		*/
	}
	return $$$OK
]]></Implementation>

</Method>

<Method name="Unsubscribe">
<ClassMethod>1</ClassMethod>
<FormalSpec>request:redis.Request,channel:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set in=request.getChannelEvent(channel) //"^redis.channels("""_channel_""")"
	if ( '$system.Event.Defined(in) ) {
		$$$TRACE("Unsubscribe but channel event does not exist!")
		return $$$OK
	}
	set ret=$system.Event.Signal(in,"UNSUBSCRIBE")
	$$$TRACE("Unsubscribe sent 'UNSUBSCRIBE' to "_in)
	return $$$OK
]]></Implementation>
</Method>

<Method name="Publish">
<ClassMethod>1</ClassMethod>
<FormalSpec>request:redis.Request,channel:%String,message:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	$$$TRACE("Publish channel="_channel_" message="_message)

	// save message for later subscriber delivery
	set i = $i($$$channelmessages(channel))
	set $$$channelmessages(channel,i)=message
	
	set client=$order($$$channels(channel,""))
	while ( client'="" ) {
		set event="^redis.channels("""_channel_""","""_client_""")"
		if ( $system.Event.Defined(event) ) {
			set ret=$system.Event.Create(event)
		}
		set ret=$system.Event.Signal(event,message)
		$$$TRACE("Publish sent message="_message_" to event="_event_" ret="_ret)
		set x=$increment(clientCount)
		set client=$order($$$channels(channel,client))
	}
	return clientCount
]]></Implementation>
</Method>

<Method name="Start">
<ClassMethod>1</ClassMethod>
<FormalSpec>request:redis.Request</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set resource="^redis.monitor("""_request.Client_""")"
	set stream = request.Stream
	$$$TRACE("redis.Monitor.Start resource="_resource_" stream.IsOpen="_stream.IsOpen)
	set ^redis.monitor=1,status=$$$OK
	set created=$system.Event.Create(resource)
	$$$TRACE(resource_" created="_created)
	while ( stream.IsOpen ) {
		set msgl=$system.Event.WaitMsg(resource)
		set msg=$list(msgl,2)
		$$$TRACE(resource_" Msg="_msg)
		if ( $list(msgl,1)'=1 ) { // not a normal wakeup event
			$$$TRACE(resource_" got timeout or delete msgl="_$listtostring(msgl))
			quit
		}
		if ( $zconvert(msg,"l")["monitor.stop" ) {
			$$$TRACE(resource_" got Monitor.Stop")
			break
		}
		if ( stream.IsOpen ) {
			//do stream.WriteLine(msg,1,.status)
			set response=$$$rBULK(msg)
			set status=response.writeToStream(.stream)
			quit:$$$ISERR(status)
		}
	}
	set deleted=$system.Event.Delete(resource)
	$$$TRACE(resource_" delete="_deleted)
	// if no other monitors running, turn off global switch
	set found=0,pmonitors=$system.Event.List()
	for i=1:1:$listlength(pmonitors) {
		if ( $list(pmonitors,i)["redis.monitor" ) {
			set found=1
		}
	}
	// TODO LOCK!
	$$$TRACE(resource_"found="_found)
	set:'found ^redis.monitor=0
	return status
]]></Implementation>
</Method>
<Method name="ForceAllMonitorsDown">
<ClassMethod>1</ClassMethod>
<FormalSpec></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set events=$system.Event.List()
	for i=1:1:$listlength(events) {
		set mon=$list(events,i)
		write "Found resource=",mon,!
		if ( mon["redis.monitor" ) {
			set sent=$system.Event.Signal(mon,"monitor.stop")
			write "Sent 'Monitor.Stop' to ",mon," sent=",sent,!
			set monitors(mon)=""
		}
		if ( mon["redis.channels" ) {
			set sent=$system.Event.Signal(mon,"UNSUBSCRIBE")
			write "Sent 'UNSUBSCRIBE' to "_mon,!
			set monitors(mon)=""
		}
	}
	if ( '$data(monitors) ) {
		write "Done."
		quit
	}
	write "Waiting"
	for i=1:1:5 { write "." hang 1 }
	write !
	set mon=$order(monitors(""))
	while ( mon'="" ) {
		if ( $system.Event.Defined(mon) ) {
			write mon," exists!, attempting to delete result="
			set dr=$system.Event.Delete(mon)
			write dr,!
		}
		set mon=$order(monitors(mon))
	}
]]></Implementation>
</Method>

</Class>

<Class name="redis.Tests">
<Super>%RegisteredObject</Super>
<TimeChanged>63054,51056.54028</TimeChanged>
<TimeCreated>63053,64497.917841</TimeCreated>

<Method name="writeAndRewind">
<ClassMethod>1</ClassMethod>
<FormalSpec>stream:%Stream,data:%List</FormalSpec>
<Implementation><![CDATA[
	set status=$$$OK
	for i=1:1:$listlength(data) {
		do stream.WriteLine( $list(data,i),1,.status )
		do:$$$ISERR(status) $system.OBJ.DisplayError(status)
	}
	do stream.Rewind()
]]></Implementation>
</Method>

<Method name="pingTest">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	set baseStream=##class(%IO.StringStream).%New()
	set baseStream.LineTerminator=$C(13,10)
	set stream=##class(%IO.MetaCharacterStream).%New(baseStream)
	
	
	write "PING",!
	set data=$listbuild("*1","$4","PING")
	do ..writeAndRewind(stream,data)
	set sc=##class(redis.Request).readFromStream(.stream,.req)
	do:$$$ISERR(sc) $system.OBJ.DisplayError(sc)
	write req.toString(),!
	zw req
	
	#dim response as redis.Response
	
	set response=##class(redis.Response).OK(,.req)
	set sc=response.writeToStream(stream)
	do:$$$ISERR(sc) $system.OBJ.DisplayError(sc)
	do stream.OutputToDevice()
	zw response
	write response.toString(),!
]]></Implementation>
</Method>

<Method name="testRequest">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	set baseStream=##class(%IO.StringStream).%New()
	set baseStream.LineTerminator=$C(13,10)
	set stream=##class(%IO.MetaCharacterStream).%New(baseStream)
	
	
	write "SET mykey myvalue",!
	set data=$listbuild("*3","$3","SET","$5","mykey","$7","myvalue")
	do ..writeAndRewind(stream,data)
	set sc=##class(redis.Request).readFromStream(.stream,.req)
	do:$$$ISERR(sc) $system.OBJ.DisplayError(sc)
	write req.toString(),!
	zw req
	#dim response as redis.Response
	
	set response=##class(redis.Response).OK(,.req)
	set sc=response.writeToStream(stream)
	do:$$$ISERR(sc) $system.OBJ.DisplayError(sc)
	do stream.OutputToDevice()
	zw response
	
	write !,"GET mykey",!
	do stream.Clear()
	set data=$lb("*2","$3","GET","$5","mykey")
	do ..writeAndRewind(stream,data)	
	set sc=##class(redis.Request).readFromStream(.stream,.req)
	do:$$$ISERR(sc) $system.OBJ.DisplayError(sc)

	zw req
	set response=##class(redis.Response).Bulk("myvalue",.req)
	set sc=response.writeToStream(stream)
	do:$$$ISERR(sc) $system.OBJ.DisplayError(sc)
 	zw response
	do stream.OutputToDevice()

	for i=1:1:3 {	
	write !,"SET key1 value1",!
		do stream.Clear()
		set data=$lb("*3","$3","SET","$4","key"_i,"$6","value"_i)
		do ..writeAndRewind(stream,data)	
		set sc=##class(redis.Request).readFromStream(.stream,.req)
     	do:$$$ISERR(sc) $system.OBJ.DisplayError(sc)
		zw req
	}
	do stream.Clear()
	write "MGET key1 key2 nonexisting",!
	set data=$lb("*4","MGET","$4","key1","$4","key2","$11","nonexisting")
	do ..writeAndRewind(stream,data)	
	set sc=##class(redis.Request).readFromStream(.stream,.req)
	do:$$$ISERR(sc) $system.OBJ.DisplayError(sc)
	zw req

	set response=##class(redis.Response).Bulk($lb("value1","value2",),.req)
	set sc=response.writeToStream(stream)
	do:$$$ISERR(sc) $system.OBJ.DisplayError(sc)

 	zw response
	do stream.OutputToDevice()
	
	write "INLINE test",!
	write "EXISTS somekey",!
	do stream.Clear()
	set data=$lb("EXISTS somekey")
	do ..writeAndRewind(stream,data)	
	set sc=##class(redis.Request).readFromStream(.stream,.req)
	do:$$$ISERR(sc) $system.OBJ.DisplayError(sc)

	zw req
]]></Implementation>
</Method>
</Class>

<Class name="redis.Production">
<IncludeCode>redis.redis</IncludeCode>
<Super>Ens.Production</Super>
<TimeChanged>63057,67327.719794</TimeChanged>
<TimeCreated>63050,42665.000963</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="redis.Production" TestingEnabled="true" LogGeneralTraceEvents="true">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="redis.Service" Category="" ClassName="redis.Service" PoolSize="3" Enabled="true" Foreground="false" Comment="" LogTraceEvents="true" Schedule="">
    <Setting Target="Adapter" Name="Port">6379</Setting>
    <Setting Target="Adapter" Name="QSize">10000</Setting>
    <Setting Target="Host" Name="ArchiveIO">0</Setting>
    <Setting Target="Host" Name="AlertOnError">1</Setting>
  </Item>
</Production>
]]></Data>
</XData>

<Method name="OnStart">
<Description>
Override this in your Production class to do setup before the Production starts</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeStarted:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	
	for glo="^redis.clients","^redis.channels","^redis.channelmessages" {
		$$$TRACE("redis.Production OnStart - clearing "_glo)
		kill @glo
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnStop">
<Description>
Override this in your Production class to do cleanup after the Production stops</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeStarted:%String,pForced:%Boolean</FormalSpec>
<Implementation><![CDATA[	Quit
]]></Implementation>
</Method>
</Class>

<Routine name="redis.redis" type="INC" timestamp="63055,69090.810914"><![CDATA[
#include Ensemble
#define DebugBuild		
	
#define HOME		$namespace		
#define log 		^redis.log
#define loglit		"^["""_^||redis.conf("dir")_"""]redis.log"
#define conf		^redis.conf
#define	pconf		^redis.conf
#define clients		^redis.clients
#define control		^redis.server
#define channels	^redis.channels
#define channelmessages	^redis.channels.messages

#define	nsPrefix	"redis"
#define	dbPrefix	"redis"
#define defaultRedisDB	"DB 0"
#define defaultNS	$$$nsPrefix_"0"
#define CRLF		$get($$$conf("crlf"),$C(13)_$C(10))
#define VERSION		"0.1"
#define LOGDEBUG	1000
#define LOGVERBOSE	100
#define LOGNOTICE	10
#define LOGWARNING	0
#define LOGALWAYS	"LOG"

#define LogFileLevel(%l)	$s(%l=$$$LOGDEBUG:"%",%l=$$$LOGVERBOSE:"$",%l=$$$LOGNOTICE:"#",1:"*")
#define	LogLevel	##expression($g($$$conf("loglevel-i"),0))
#define LoggerResource	"RedisLogger"
#define	fs		##expression(""""_$s($$$isWINDOWS:"\",$$$isUNIX:"/",$$$isVMS:"")_"""")
#ifdef	DebugBuild
	#define debug(%msg)	do logdebug^redis(%msg)
	#define	CompileStamp    ##expression("	/* Compiled on "_$ZDT($ZTS)_" by "_$username_" DEBUG BUILD */")
#else
	#define debug(%msg)	// no debug	
	#define	CompileStamp    ##expression("	/* Compiled on "_$ZDT($ZTS)_" by "_$username_" RELEASE BUILD*/")
#endif

#; How long should subscribers alertnate between listening on channel 
#; and checking for new requests, in seconds
#define PUBSUBPOLLINTERAL	5

#; data storage definitions
#define keys		^[$$$clients(request.Client,"db")]keys
#define	sets		^[$$$clients(request.Client,"db")]sets
#define lists		^[$$$clients(request.Client,"db")]lists
#define	hashes		^[$$$clients(request.Client,"db")]hashes

#; response macros
#define rBULK(%1)	##class(redis.Response).Bulk(%1,request)
#define rERROR(%1)  ##class(redis.Response).Error(%1,request)
#; Does Not Exist Error
#define rDNE		$$$rERROR(1)
#define rOK			##class(redis.Response).OK(,request)
#define rOKMSG(%1)	##class(redis.Response).OK(%1,request)
#define rINT(%1)	##class(redis.Response).Int(%1,request)
]]></Routine>
</Export>
